<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="author" content="Jonah Gabry and Ben Goodrich" />

<meta name="date" content="2015-01-06" />

<title>Estimating Ordinal Regression Models with rstanarm</title>

<script src="polr_files/jquery-1.11.0/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="polr_files/bootstrap-3.3.1/css/bootstrap.min.css" rel="stylesheet" />
<script src="polr_files/bootstrap-3.3.1/js/bootstrap.min.js"></script>
<script src="polr_files/bootstrap-3.3.1/shim/html5shiv.min.js"></script>
<script src="polr_files/bootstrap-3.3.1/shim/respond.min.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet"
      href="polr_files/highlight/default.css"
      type="text/css" />
<script src="polr_files/highlight/highlight.js"></script>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img { 
  max-width:100%; 
  height: auto; 
}
</style>
<div class="container-fluid main-container">


<div id="header">
<h1 class="title">Estimating Ordinal Regression Models with rstanarm</h1>
<h4 class="author"><em>Jonah Gabry and Ben Goodrich</em></h4>
<h4 class="date"><em>01/06/2015</em></h4>
</div>

<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#likelihood">Likelihood</a></li>
<li><a href="#priors">Priors</a></li>
<li><a href="#example">Example</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</div>

<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{stan_polr: Ordinal Models}
-->
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>This vignette explains how to estimate models for ordinal outcomes using the <code>stan_polr</code> function in the <strong>rstanarm</strong> package.</p>
<p>The four steps of a Bayesian analysis are</p>
<ol style="list-style-type: decimal">
<li>Specify a joint distribution for the outcome(s) and all the unknowns, which typically takes the form of a marginal prior distribution for the unknowns multiplied by a likelihood for the outcome(s) conditional on the unknowns. This joint distribution is proportional to a posterior distribution of the unknowns conditional on the observed data</li>
<li>Draw from posterior distribution using Markov Chain Monte Carlo (MCMC).</li>
<li>Evaluate how well the model fits the data and possibly revise the model.</li>
<li>Draw from the posterior predictive distribution of the outcome(s) given interesting values of the predictors in order to visualize how a manipulation of a predictor affects (a function of) the outcome(s).</li>
</ol>
<p>Steps 3 and 4 are covered in more depth by the vignette entitled “How to Use the <strong>rstanarm</strong> Package”. This vignette focuses on Step 1.</p>
<p>One of the strengths of doing MCMC with Stan — as opposed to a Gibbs sampler — is that reparameterizations are essentially costless, which allows the user to specify priors on parameters that are either more intuitive, numerically stable, or computationally efficient without changing the posterior distribution of the parameters that enter the likelihood. Advantageous parameterizations are already built into the Stan programs used in the <strong>rstanarm</strong> package, so it is just a matter of using these vignettes to explain how the priors work in the context of these reparameterizations.</p>
</div>
<div id="likelihood" class="section level1">
<h1>Likelihood</h1>
<p>Ordinal outcomes fall in one of <span class="math inline">\(J\)</span> categories. One way to motivate an ordinal model is to introduce a latent variable, <span class="math inline">\(y^\ast\)</span>, that is related to the observed outcomes via an observation mechanism: <span class="math display">\[y=\begin{cases}
1 &amp; \mbox{if }y^{\ast}&lt;\zeta_{1}\\
2 &amp; \mbox{if }\zeta_{1}\leq y^{\ast}&lt;\zeta_{2}\\
\vdots\\
J &amp; \mbox{if }\zeta_{J-1}\leq y^{\ast}
\end{cases},\]</span> where <span class="math inline">\(\boldsymbol{\zeta}\)</span> is a vector of cutpoints of length <span class="math inline">\(J-1\)</span>.</p>
<p>Then <span class="math inline">\(y^\ast\)</span> is modeled as a linear function of <span class="math inline">\(K\)</span> predictors <span class="math display">\[y^\ast = \mu + \epsilon = \mathbf{x}^\top \boldsymbol{\beta} + \epsilon,\]</span> where <span class="math inline">\(\epsilon\)</span> has mean zero and unit scale but can be specified as being drawn from one of several distributions. Note that there is no “intercept” in this model since the data cannot distinguish an intercept from the cutpoints. However, if <span class="math inline">\(J = 2\)</span>, then <span class="math inline">\(\zeta_1\)</span> can be referred to as either the cutpoint or the intercept.</p>
<p>A Bayesian can treat <span class="math inline">\(y^\ast\)</span> as another unknown parameter, although for computational efficiency the Stan code essentially integrates each <span class="math inline">\(y^\ast\)</span> out of the posterior distribution, leaving the posterior distribution of <span class="math inline">\(\boldsymbol{\beta}\)</span> and <span class="math inline">\(\boldsymbol{\zeta}\)</span>. Nevertheless, it is useful to motivate the model theoretically as if <span class="math inline">\(y^\ast\)</span> were just an unknown parameter with a distribution truncated by the relevant element(s) of <span class="math inline">\(\boldsymbol{\zeta}\)</span>.</p>
</div>
<div id="priors" class="section level1">
<h1>Priors</h1>
<p>If <span class="math inline">\(y^\ast\)</span> were observed we would simply have a linear regression model for it, and the description of the priors in the vignette entitled “Estimating Linear Models with the <strong>rstanarm</strong> Package” would apply directly. Another way to say the same thing is <em>conditional</em> on a realization of <span class="math inline">\(y^\ast\)</span>, we have a linear regression model and the description of the priors in the other vignette does apply (and should be read before continuing with this subsection).</p>
<p>The <code>stan_lm</code> function essentially specifies a prior on <span class="math inline">\(\boldsymbol{\theta} = \mathbf{R}^{-1} \boldsymbol{\beta}\)</span>, where <span class="math inline">\(\mathbf{R}\)</span> is the upper triangular matrix in the QR decomposition of the design matrix, <span class="math inline">\(\mathbf{X} = \mathbf{Q} \mathbf{R}\)</span>. Furthermore, in <code>stan_lm</code>, <span class="math inline">\(\sigma_{\epsilon} = \sigma_y \sqrt{1 - R^2}\)</span> where <span class="math inline">\(R^2\)</span> is the proportion of variance in the outcome that is attributable to the coefficients in a linear model.</p>
<p>The main difference in the context of a model for an ordinal outcome is that the scale of <span class="math inline">\(y^\ast\)</span> is not identified by the data. Thus, the ordinal model specifies that <span class="math inline">\(\sigma_{\epsilon} = 1\)</span>, which implies that <span class="math inline">\(\sigma_{y^\ast} = 1 / \sqrt{1 - R^2}\)</span> is an intermediate parameter rather than a primitive parameter.</p>
<p>It is somewhat more difficult to specify a prior value for the <span class="math inline">\(R^2\)</span> in an ordinal model because <span class="math inline">\(R^2\)</span> refers to the proportion of variance in the  <span class="math inline">\(y^\ast\)</span> that is attributable to the predictors under a linear model. In general, the <span class="math inline">\(R^2\)</span> tends to be lower in an ordinal model than in a linear model where the continuous outcome is observed.</p>
<p>The other difference is that an ordinal model does not have a global intercept but rather a vector of <span class="math inline">\(J-1\)</span> cutpoints. The implied prior on these cutpoints used by the <strong>rstanarm</strong> package is somewhat novel. The user instead specifies a Dirichlet prior on <span class="math inline">\(\Pr\left(y=j\right)\left.\right|\overline{\mathbf{x}}\)</span>, which is to say the prior probability of the outcome falling in each of the <span class="math inline">\(J\)</span> categories given that the predictors are at their sample means. The Dirichlet prior is for a simplex random variable, whose elements are non-negative and sum to <span class="math inline">\(1\)</span>. The Dirichlet PDF can be written as <span class="math display">\[f\left(\boldsymbol{\pi}|\boldsymbol{\alpha}\right) \propto 
\prod_{j=1}^J{\pi_j^{\alpha_j - 1}}, \]</span> where <span class="math inline">\(\boldsymbol{\pi}\)</span> is a simplex vector such that <span class="math inline">\(\pi_j = \Pr\left(y=j\right)\left.\right|\overline{\mathbf{x}}\)</span>.</p>
<p>The Dirichlet prior is one of the easiest to specify because the so-called “concentration” hyperparameters <span class="math inline">\(\boldsymbol{\alpha}\)</span> can be interpreted as prior counts, i.e., prior observations for each of the J categories (although they need not be integers). If <span class="math inline">\(\alpha_j = 1\)</span> for every <span class="math inline">\(j\)</span> (the default used by <strong>rstanarm</strong>) then the Dirichlet prior is jointly uniform over the space of these simplexes. This corresponds to a prior count of one observation falling in each of the <span class="math inline">\(J\)</span> ordinal categories when the predictors are at their sample means and conveys the reasonable but weak prior information that no category has probability zero. If, for each <span class="math inline">\(j\)</span>, <span class="math inline">\(\alpha_j = \alpha &gt; 1\)</span> then the prior mode is that the <span class="math inline">\(J\)</span> categories are equiprobable, with prior probability <span class="math inline">\(1/J\)</span> of the outcome falling in each of the <span class="math inline">\(J\)</span> categories. The larger the value of <span class="math inline">\(\alpha\)</span> the more sharply peaked the distribution is at the mode.</p>
<p>The <span class="math inline">\(j\)</span>-th cutpoint <span class="math inline">\(\zeta_j\)</span> is then given by <span class="math display">\[\zeta_j = F_{y^\ast}^{-1}\left(\sum_{i=1}^j{\pi_i}\right),\]</span> where <span class="math inline">\(F_{y^\ast}^{-1}\)</span> is an inverse CDF function, which depends on the assumed distribution of <span class="math inline">\(y^\ast\)</span>. Common choices include the normal and logistic distributions. The scale parameter of this distribution is again <span class="math inline">\(\sigma_{y^\ast} = 1/\sqrt{1 - R^2}\)</span>. In short, by making each <span class="math inline">\(\zeta_j\)</span> a function of <span class="math inline">\(\boldsymbol{\pi}\)</span>, it allows us to specify a Dirichlet prior on <span class="math inline">\(\boldsymbol{\pi}\)</span>, which is simpler than specifying a prior on <span class="math inline">\(\boldsymbol{\zeta}\)</span> directly.</p>
</div>
<div id="example" class="section level1">
<h1>Example</h1>
<p>In this section, we start with an ordinal model of tobacco consumption as a function of age and alcohol consumption. Frequentist estimates can be obtained using the <code>polr</code> function in the <strong>MASS</strong> package:</p>
<pre class="r"><code>library(MASS)
print(polr(tobgp ~ agegp + alcgp, data = esoph), digits = 1)</code></pre>
<pre><code>Call:
polr(formula = tobgp ~ agegp + alcgp, data = esoph)

Coefficients:
agegp.L agegp.Q agegp.C agegp^4 agegp^5 alcgp.L alcgp.Q alcgp.C 
  -0.37   -0.38   -0.24    0.04   -0.04   -0.19   -0.02    0.03 

Intercepts:
0-9g/day|10-19    10-19|20-29      20-29|30+ 
          -1.0            0.2            1.3 

Residual Deviance: 241.8195 
AIC: 263.8195 </code></pre>
<p>To obtain Bayesian estimates, we prepend <code>stan_</code> and specify the priors:</p>
<pre class="r"><code>library(rstanarm)
post0 &lt;- stan_polr(tobgp ~ agegp + alcgp, data = esoph, 
                   prior = R2(0.25), prior_counts = dirichlet(1),
                   chains = CHAINS, cores = CORES, seed = SEED, iter = 200)</code></pre>
<pre class="r"><code>print(post0, digits = 1)</code></pre>
<pre><code>stan_polr(formula = tobgp ~ agegp + alcgp, data = esoph, chains = CHAINS, 
    cores = CORES, seed = SEED, iter = 200, prior = R2(0.25), 
    prior_counts = dirichlet(1))

Estimates:
        Median MAD_SD
agegp.L -0.2    0.3  
agegp.Q -0.2    0.4  
agegp.C -0.1    0.3  
agegp^4  0.0    0.3  
agegp^5 -0.1    0.3  
alcgp.L -0.1    0.3  
alcgp.Q  0.0    0.3  
alcgp.C  0.0    0.3  

Cutpoints:
               Median MAD_SD
0-9g/day|10-19 -1.0    0.2  
10-19|20-29     0.2    0.2  
20-29|30+       1.3    0.2  

Sample avg. posterior predictive 
distribution of y (X = xbar):
                  Median MAD_SD
mean_PPD:0-9g/day 0.3    0.1   
mean_PPD:10-19    0.3    0.1   
mean_PPD:20-29    0.2    0.1   
mean_PPD:30+      0.2    0.1   </code></pre>
<p>The point estimates, represented by the posterior medians, are qualitatively similar to the maximum-likelihood estimates but are somewhat shrunk toward zero due to the regularizing prior on the coefficients. The estimated cutpoints are <span class="math inline">\(\zeta_1 = -1.01\)</span>, <span class="math inline">\(\zeta_2 = 0.2\)</span>, and <span class="math inline">\(\zeta_3 = 1.26\)</span>, which cut at <span class="math inline">\(10\)</span>, <span class="math inline">\(20\)</span>, and <span class="math inline">\(30\)</span> grams of tobacco consumption per day. Since these cutpoints are actually <em>known</em>, it would be more appropriate for the model to take that into account, but <code>stan_polr</code> does not currently support that.</p>
<p>Next, we utilize an example from the <strong>MASS</strong> package where low birthweight is the binary outcome of interest. First, we recode some of the variables:</p>
<pre class="r"><code>data(&quot;birthwt&quot;, package = &quot;MASS&quot;)
birthwt$race &lt;- factor(birthwt$race, levels = 1:3, 
                       labels = c(&quot;white&quot;, &quot;black&quot;, &quot;other&quot;))
birthwt$bwt &lt;- birthwt$bwt / 1000 # convert from grams to kilograms
birthwt$low &lt;- factor(birthwt$low, levels = 0:1, labels = c(&quot;no&quot;, &quot;yes&quot;))</code></pre>
<p>It is usually a good idea to rescale variables by constants so that all the numbers are in single or double digits. We start by estimating a linear model for birthweight in kilograms, flipping the sign so that positive coefficients are associated with <em>lower</em> birthweights.</p>
<pre class="r"><code>post1 &lt;- stan_lm(-bwt ~ smoke + age + race + ptl + ht + ftv,
                 data = birthwt, prior = R2(0.5), 
                 chains = CHAINS, cores = CORES, seed = SEED)</code></pre>
<pre class="r"><code>print(post1)</code></pre>
<pre><code>stan_lm(formula = -bwt ~ smoke + age + race + ptl + ht + ftv, 
    data = birthwt, chains = CHAINS, cores = CORES, seed = SEED, 
    prior = R2(0.5))

Estimates:
              Median MAD_SD
(Intercept)   -3.3    0.2  
smoke          0.4    0.1  
age            0.0    0.0  
raceblack      0.4    0.2  
raceother      0.4    0.1  
ptl            0.2    0.1  
ht             0.4    0.2  
ftv            0.0    0.0  
sigma          0.7    0.0  
log-fit_ratio  0.0    0.1  
R2             0.2    0.0  

Sample avg. posterior predictive 
distribution of y (X = xbar):
         Median MAD_SD
mean_PPD -2.9    0.7  </code></pre>
<p>Next, we estimate an “ordinal” model for the incidence of low birthweight, which is defined as a birth weight of less than <span class="math inline">\(2.5\)</span> kilograms. Even though this outcome is binary, a binary variable is a special case of an ordinal variable with <span class="math inline">\(J=2\)</span> categories and is acceptable to <code>stan_polr</code>. We can think of <code>bwt</code> as something proportional to <span class="math inline">\(y^\ast\)</span> and pretend that it is not observed, forcing us to estimate an ordinal model.</p>
<pre class="r"><code>post2 &lt;- stan_polr(low ~ smoke + age + race + ptl + ht + ftv, data = birthwt,
                   prior = R2(0.5), prior_counts = dirichlet(c(1,1)), 
                   method = &quot;probit&quot;, 
                   chains = CHAINS, cores = CORES, seed = SEED)</code></pre>
<pre class="r"><code>plot(loo(post2))</code></pre>
<p><img src="SVGs/unnamed-chunk-8-1.svg" title="" alt="" width="672" style="display: block; margin: auto;" /></p>
<p>This prior seems to have worked well in this case because none of the points in the plot are above <span class="math inline">\(0.5\)</span>, which would have indicated the the posterior is very sensitive to those observations. If we compare the estimated coefficients,</p>
<pre class="r"><code>round(cbind(Linear = coef(post1), Ordinal = coef(post2), 
            Rescaled = coef(post1) / sigma(post1)), 3)</code></pre>
<pre><code>            Linear Ordinal Rescaled
(Intercept) -3.265  -0.563   -4.832
smoke        0.365   0.516    0.540
age         -0.003  -0.024   -0.004
raceblack    0.392   0.529    0.580
raceother    0.405   0.548    0.599
ptl          0.150   0.406    0.222
ht           0.371   0.710    0.548
ftv         -0.002  -0.009   -0.004</code></pre>
<p>they have the same signs and similar magnitudes, with the exception of the “Intercept”. In an ordinal model where the outcome only has <span class="math inline">\(J=2\)</span> categories, this “Intercept” is actually <span class="math inline">\(\zeta_1\)</span>, but it is more conventional to call it the “Intercept” so that it agrees with <code>stan_glm</code> when <code>family = binomial(link = 'probit')</code>. Recall that <span class="math inline">\(\sigma_{\epsilon} = 1\)</span> in an ordinal model, so if we rescale the coefficients from a linear model by dividing by the posterior median of <span class="math inline">\(\sigma\)</span>, the resulting coefficients are even closer to those of the ordinal model.</p>
<p>This illustrates the fundamental similarity between a linear model for a continuous observed outcome and a linear model for a latent <span class="math inline">\(y^\ast\)</span> that generates an ordinal observed outcome. The main difference is when the outcome is continuous and observed, we can estimate the scale of the errors meaningfully. When the outcome is ordinal, we can only fix the scale of the latent errors to <span class="math inline">\(1\)</span> arbitrarily.</p>
<p>Finally, when <span class="math inline">\(J = 2\)</span>, the <code>stan_polr</code> function allows you to specify non-<code>NULL</code> values of the <code>shape</code> and <code>rate</code> arguments, which implies a “scobit” likelihood where the probability of success is given by <span class="math inline">\(F\left(y^\ast \right)^\alpha\)</span>, where <span class="math inline">\(F\left(\right)\)</span> is the logistic CDF and <span class="math inline">\(\alpha &gt; 0\)</span> is a skewing parameter that has a gamma prior with a given <code>shape</code> and <code>rate</code>. If <span class="math inline">\(\alpha \neq 1\)</span>, then the relationship between <span class="math inline">\(y^\ast\)</span> and the probability of success is asymmetric. In principle, it seems appropriate to estimate <span class="math inline">\(\alpha\)</span> but in practice, a lot of data is needed to estimate <span class="math inline">\(\alpha\)</span> with adequate precision. In the previous example, if we specify <code>shape = 2</code> and <code>rate = 2</code> to reflect the prior beliefs that <span class="math inline">\(\alpha\)</span> is expected to be <span class="math inline">\(1\)</span> but has a variance of <span class="math inline">\(\frac{1}{2}\)</span>, then the <code>loo</code> calculation yields many Pareto shape parameters that are excessively large. However, with more than <span class="math inline">\(189\)</span> observations, such a model may be more fruitful.</p>
</div>
<div id="conclusion" class="section level1">
<h1>Conclusion</h1>
<p>The posterior distribution for an ordinal model requires priors on the coefficients and the cutpoints. The priors used by the <code>stan_polr</code> function are unconventional but should work well for a variety of problems. The prior on the coefficients is essentially the same as that used by the <code>stan_lm</code> function but omits a scale parameter because the standard deviation of the latent <span class="math inline">\(y^\ast\)</span> is not identified by the data. The cutpoints are conditionally deterministic given a simplex vector for the probability of falling in each of the <span class="math inline">\(J\)</span> ordinal categories given that the predictors are at their sample means. Thus, a Dirichlet prior — which is relatively easy to specify and has a good default of jointly uniform — on this simplex completes the posterior distribution.</p>
<p>This approach provides an alternative to <code>stan_glm</code> with <code>family = binomial()</code> even if the outcome variable has only two categories. The <code>stan_glm</code> function has more options for the prior on the coefficients and the prior on the intercept (which can be interpreted as the first cutpoint when <span class="math inline">\(J = 2\)</span>). However, it may be more difficult to obtain efficient sampling with those priors.</p>
</div>


</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
