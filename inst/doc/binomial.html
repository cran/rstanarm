<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Jonah Gabry and Ben Goodrich" />

<meta name="date" content="2019-10-01" />

<title>Estimating Generalized Linear Models for Binary and Binomial Data with rstanarm</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#header {
text-align: center;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; }  code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>

</head>

<body>




<h1 class="title toc-ignore">Estimating Generalized Linear Models for Binary and Binomial Data with rstanarm</h1>
<h4 class="author"><em>Jonah Gabry and Ben Goodrich</em></h4>
<h4 class="date"><em>2019-10-01</em></h4>


<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#likelihood">Likelihood</a></li>
<li><a href="#priors">Priors</a></li>
<li><a href="#posterior">Posterior</a></li>
<li><a href="#logistic-regression-example">Logistic Regression Example</a></li>
<li><a href="#conditional-logit-models">Conditional Logit Models</a></li>
<li><a href="#binomial-models">Binomial Models</a></li>
<li><a href="#going-further">Going Further</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>

<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{stan_glm: GLMs for Binary and Binomial Data}
-->
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>This vignette explains how to estimate generalized linear models (GLMs) for binary (Bernoulli) and Binomial response variables using the <code>stan_glm</code> function in the <strong>rstanarm</strong> package.</p>
<p>Steps 3 and 4 are covered in more depth by the vignette entitled <a href="rstanarm.html">“How to Use the <strong>rstanarm</strong> Package”</a>. This vignette focuses on Step 1 when the likelihood is the product of conditionally independent binomial distributions (possibly with only one trial per observation).</p>
</div>
<div id="likelihood" class="section level1">
<h1>Likelihood</h1>
<p>For a binomial GLM the likelihood for one observation <span class="math inline">\(y\)</span> can be written as a conditionally binomial PMF <span class="math display">\[\binom{n}{y} \pi^{y} (1 - \pi)^{n - y},\]</span> where <span class="math inline">\(n\)</span> is the known number of trials, <span class="math inline">\(\pi = g^{-1}(\eta)\)</span> is the probability of success and <span class="math inline">\(\eta = \alpha + \mathbf{x}^\top \boldsymbol{\beta}\)</span> is a linear predictor. For a sample of size <span class="math inline">\(N\)</span>, the likelihood of the entire sample is the product of <span class="math inline">\(N\)</span> individual likelihood contributions.</p>
<p>Because <span class="math inline">\(\pi\)</span> is a probability, for a binomial model the <em>link</em> function <span class="math inline">\(g\)</span> maps between the unit interval (the support of <span class="math inline">\(\pi\)</span>) and the set of all real numbers <span class="math inline">\(\mathbb{R}\)</span>. When applied to a linear predictor <span class="math inline">\(\eta\)</span> with values in <span class="math inline">\(\mathbb{R}\)</span>, the inverse link function <span class="math inline">\(g^{-1}(\eta)\)</span> therefore returns a valid probability between 0 and 1.</p>
<p>The two most common link functions used for binomial GLMs are the <a href="https://en.wikipedia.org/wiki/Logit">logit</a> and <a href="https://en.wikipedia.org/wiki/Probit">probit</a> functions. With the logit (or log-odds) link function <span class="math inline">\(g(x) = \ln{\left(\frac{x}{1-x}\right)}\)</span>, the likelihood for a single observation becomes</p>
<p><span class="math display">\[\binom{n}{y}\left(\text{logit}^{-1}(\eta)\right)^y 
\left(1 - \text{logit}^{-1}(\eta)\right)^{n-y} = 
\binom{n}{y} \left(\frac{e^{\eta}}{1 + e^{\eta}}\right)^{y}
\left(\frac{1}{1 + e^{\eta}}\right)^{n - y}\]</span></p>
<p>and the probit link function <span class="math inline">\(g(x) = \Phi^{-1}(x)\)</span> yields the likelihood</p>
<p><span class="math display">\[\binom{n}{y} \left(\Phi(\eta)\right)^{y}
\left(1 - \Phi(\eta)\right)^{n - y},\]</span></p>
<p>where <span class="math inline">\(\Phi\)</span> is the CDF of the standard normal distribution. The differences between the logit and probit functions are minor and – if, as <strong>rstanarm</strong> does by default, the probit is scaled so its slope at the origin matches the logit’s – the two link functions should yield similar results. With <code>stan_glm</code>, binomial models with a logit link function can typically be fit slightly faster than the identical model with a probit link because of how the two models are implemented in Stan. Unless the user has a specific reason to prefer the probit link, we recommend the logit simply because it will be slightly faster and more numerically stable.</p>
<p>In theory, there are infinitely many possible link functions, although in practice only a few are typically used. Other common choices are the <code>cauchit</code> and <code>cloglog</code> functions, which can also be used with <code>stan_glm</code> (every link function compatible with<code>glm</code> will work with <code>stan_glm</code>).</p>
</div>
<div id="priors" class="section level1">
<h1>Priors</h1>
</div>
<div id="posterior" class="section level1">
<h1>Posterior</h1>
<p>With independent prior distributions, the joint posterior distribution for <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\boldsymbol{\beta}\)</span> is proportional to the product of the priors and the <span class="math inline">\(N\)</span> likelihood contributions:</p>
<p><span class="math display">\[f\left(\alpha,\boldsymbol{\beta} | \mathbf{y},\mathbf{X}\right) \propto
  f\left(\alpha\right) \times \prod_{k=1}^K f\left(\beta_k\right) \times
  \prod_{i=1}^N {
  g^{-1}\left(\eta_i\right)^{y_i} 
  \left(1 - g^{-1}\left(\eta_i\right)\right)^{n_i-y_i}}.\]</span></p>
<p>This is posterior distribution that <code>stan_glm</code> will draw from when using MCMC.</p>
</div>
<div id="logistic-regression-example" class="section level1">
<h1>Logistic Regression Example</h1>
<p>When the logit link function is used the model is often referred to as a logistic regression model (the inverse logit function is the CDF of the standard logistic distribution). As an example, here we will show how to carry out a few parts of the analysis from Chapter 5.4 of <a href="http://www.stat.columbia.edu/~gelman/arm/">Gelman and Hill (2007)</a> using <code>stan_glm</code>.</p>
<p>Gelman and Hill describe a survey of 3200 residents in a small area of Bangladesh suffering from arsenic contamination of groundwater. Respondents with elevated arsenic levels in their wells had been encouraged to switch their water source to a safe public or private well in the nearby area and the survey was conducted several years later to learn which of the affected residents had switched wells. The goal of the analysis presented by Gelman and Hill is to learn about the factors associated with switching wells.</p>
<p>To start, we’ll use <code>dist</code> (the distance from the respondent’s house to the nearest well with safe drinking water) as the only predictor of <code>switch</code> (1 if switched, 0 if not). Then we’ll expand the model by adding the arsenic level of the water in the resident’s own well as a predictor and compare this larger model to the original.</p>
<p>After loading the <code>wells</code> data, we first rescale the <code>dist</code> variable (measured in meters) so that it is measured in units of 100 meters. If we leave <code>dist</code> in its original units then the corresponding regression coefficient will represent the effect of the marginal meter, which is too small to have a useful interpretation.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">library</span>(rstanarm)</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">data</span>(wells)</a>
<a class="sourceLine" id="cb1-3" title="3">wells<span class="op">$</span>dist100 &lt;-<span class="st"> </span>wells<span class="op">$</span>dist <span class="op">/</span><span class="st"> </span><span class="dv">100</span></a></code></pre></div>
<p>Before estimating any models we can visualize the distribution of <code>dist100</code> in the data:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">ggplot</span>(wells, <span class="kw">aes</span>(<span class="dt">x =</span> dist100, <span class="dt">y =</span> ..density.., <span class="dt">fill =</span> <span class="cf">switch</span> <span class="op">==</span><span class="st"> </span><span class="dv">1</span>)) <span class="op">+</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="st">  </span><span class="kw">geom_histogram</span>() <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="st">  </span><span class="kw">scale_fill_manual</span>(<span class="dt">values =</span> <span class="kw">c</span>(<span class="st">&quot;gray30&quot;</span>, <span class="st">&quot;skyblue&quot;</span>))</a></code></pre></div>
<p>In the plot above the blue bars correspond to the 1737 residents who said they switched wells and darker bars show the distribution of <code>dist100</code> for the 1283 residents who didn’t switch. As we would expect, for the residents who switched wells, the distribution of <code>dist100</code> is more concentrated at smaller distances.</p>
<p>A Bayesian version of Gelman and Hill’s initial logistic regression model can be estimated using the <code>stan_glm</code> function. Here we’ll use a Student t prior with 7 degrees of freedom and a scale of 2.5, which, as discussed above, is a reasonable default prior when coefficients should be close to zero but have some chance of being large.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" title="1">t_prior &lt;-<span class="st"> </span><span class="kw">student_t</span>(<span class="dt">df =</span> <span class="dv">7</span>, <span class="dt">location =</span> <span class="dv">0</span>, <span class="dt">scale =</span> <span class="fl">2.5</span>, <span class="dt">autoscale =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb3-2" title="2">fit1 &lt;-<span class="st"> </span><span class="kw">stan_glm</span>(<span class="cf">switch</span> <span class="op">~</span><span class="st"> </span>dist100, <span class="dt">data =</span> wells, </a>
<a class="sourceLine" id="cb3-3" title="3">                 <span class="dt">family =</span> <span class="kw">binomial</span>(<span class="dt">link =</span> <span class="st">&quot;logit&quot;</span>), </a>
<a class="sourceLine" id="cb3-4" title="4">                 <span class="dt">prior =</span> t_prior, <span class="dt">prior_intercept =</span> t_prior,  </a>
<a class="sourceLine" id="cb3-5" title="5">                 <span class="dt">cores =</span> <span class="dv">2</span>, <span class="dt">seed =</span> <span class="dv">12345</span>)</a></code></pre></div>
<p>The <code>formula</code>, <code>data</code> and <code>family</code> arguments to <code>stan_glm</code> are specified in exactly the same way as for <code>glm</code>. We’ve also added the optional additional arguments <code>chains</code> (how many chains we want to execute), <code>cores</code> (how many cores we want the computer to utilize) and <code>seed</code> (for reproducibility). You can read about other possible arguments in the <code>stan_glm</code> documentation (<code>help(stan_glm, package = 'rstanarm')</code>).</p>
<p>To get a sense for the uncertainty in our estimates we can use the <code>posterior_interval</code> function to get Bayesian uncertainty intervals. The uncertainty intervals are computed by finding the relevant quantiles of the draws from the posterior distribution. For example, to compute 50% intervals we use:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">round</span>(<span class="kw">posterior_interval</span>(fit1, <span class="dt">prob =</span> <span class="fl">0.5</span>), <span class="dv">2</span>)</a></code></pre></div>
<p>For more on <code>posterior_interval</code> and interpreting the parameter estimates from a Bayesian model see Step 2 in the <a href="rstanarm.html">“How to Use the <strong>rstanarm</strong> Package”</a> vignette.</p>
<p>Using the coefficient estimates we can plot the predicted probability of <code>switch = 1</code> (as a function of <code>dist100</code>) together with the observed outcomes:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" title="1"><span class="co"># Predicted probability as a function of x</span></a>
<a class="sourceLine" id="cb5-2" title="2">pr_switch &lt;-<span class="st"> </span><span class="cf">function</span>(x, ests) <span class="kw">plogis</span>(ests[<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>ests[<span class="dv">2</span>] <span class="op">*</span><span class="st"> </span>x)</a>
<a class="sourceLine" id="cb5-3" title="3"><span class="co"># A function to slightly jitter the binary data</span></a>
<a class="sourceLine" id="cb5-4" title="4">jitt &lt;-<span class="st"> </span><span class="cf">function</span>(...) {</a>
<a class="sourceLine" id="cb5-5" title="5">  <span class="kw">geom_point</span>(<span class="kw">aes_string</span>(...), <span class="dt">position =</span> <span class="kw">position_jitter</span>(<span class="dt">height =</span> <span class="fl">0.05</span>, <span class="dt">width =</span> <span class="fl">0.1</span>), </a>
<a class="sourceLine" id="cb5-6" title="6">             <span class="dt">size =</span> <span class="dv">2</span>, <span class="dt">shape =</span> <span class="dv">21</span>, <span class="dt">stroke =</span> <span class="fl">0.2</span>)</a>
<a class="sourceLine" id="cb5-7" title="7">}</a>
<a class="sourceLine" id="cb5-8" title="8"><span class="kw">ggplot</span>(wells, <span class="kw">aes</span>(<span class="dt">x =</span> dist100, <span class="dt">y =</span> <span class="cf">switch</span>, <span class="dt">color =</span> <span class="cf">switch</span>)) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="st">  </span><span class="kw">scale_y_continuous</span>(<span class="dt">breaks =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">0.5</span>, <span class="dv">1</span>)) <span class="op">+</span></a>
<a class="sourceLine" id="cb5-10" title="10"><span class="st">  </span><span class="kw">jitt</span>(<span class="dt">x=</span><span class="st">&quot;dist100&quot;</span>) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb5-11" title="11"><span class="st">  </span><span class="kw">stat_function</span>(<span class="dt">fun =</span> pr_switch, <span class="dt">args =</span> <span class="kw">list</span>(<span class="dt">ests =</span> <span class="kw">coef</span>(fit1)), </a>
<a class="sourceLine" id="cb5-12" title="12">                <span class="dt">size =</span> <span class="dv">2</span>, <span class="dt">color =</span> <span class="st">&quot;gray35&quot;</span>)</a></code></pre></div>
<p>The plot shows that under this model the predicted probability of switching is a decent bit above 50% for residents living very close to wells with safe drinking water. As expected, larger values of <code>dist100</code> are associated with lower predicted probabilities of switching. At the extreme (<span class="math inline">\(\approx 300\)</span> meters), the probability is about 25%.</p>
<p>Next, we incorporate an additional predictor into the model: the arsenic level of water in the respondent’s well. According to Gelman and Hill, “At the levels present in the Bangladesh drinking water, the health risks from arsenic are roughly proportional to exposure, and so we would expect switching to be more likely from wells with high arsenic levels” (pg. 90). We only need to change the formula, so we can use the <code>update</code> function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" title="1">fit2 &lt;-<span class="st"> </span><span class="kw">update</span>(fit1, <span class="dt">formula =</span> <span class="cf">switch</span> <span class="op">~</span><span class="st"> </span>dist100 <span class="op">+</span><span class="st"> </span>arsenic) </a></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" title="1">(coef_fit2 &lt;-<span class="st"> </span><span class="kw">round</span>(<span class="kw">coef</span>(fit2), <span class="dv">3</span>))</a></code></pre></div>
<p>As expected the coefficient on <code>arsenic</code> is positive. The plot below shows distance on the x-axis and arsenic level on the y-axis with the predicted probability of well-switching mapped to the color of the background tiles (the lighter the color the higher the probability). The observed value of <code>switch</code> is indicated by the color of the points.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" title="1">pr_switch2 &lt;-<span class="st"> </span><span class="cf">function</span>(x, y, ests) <span class="kw">plogis</span>(ests[<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>ests[<span class="dv">2</span>] <span class="op">*</span><span class="st"> </span>x <span class="op">+</span><span class="st"> </span>ests[<span class="dv">3</span>] <span class="op">*</span><span class="st"> </span>y)</a>
<a class="sourceLine" id="cb8-2" title="2">grid &lt;-<span class="st"> </span><span class="kw">expand.grid</span>(<span class="dt">dist100 =</span> <span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">4</span>, <span class="dt">length.out =</span> <span class="dv">100</span>), </a>
<a class="sourceLine" id="cb8-3" title="3">                    <span class="dt">arsenic =</span> <span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dt">length.out =</span> <span class="dv">100</span>))</a>
<a class="sourceLine" id="cb8-4" title="4">grid<span class="op">$</span>prob &lt;-<span class="st"> </span><span class="kw">with</span>(grid, <span class="kw">pr_switch2</span>(dist100, arsenic, <span class="kw">coef</span>(fit2)))</a>
<a class="sourceLine" id="cb8-5" title="5"><span class="kw">ggplot</span>(grid, <span class="kw">aes</span>(<span class="dt">x =</span> dist100, <span class="dt">y =</span> arsenic)) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="st">  </span><span class="kw">geom_tile</span>(<span class="kw">aes</span>(<span class="dt">fill =</span> prob)) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">data =</span> wells, <span class="kw">aes</span>(<span class="dt">color =</span> <span class="kw">factor</span>(<span class="cf">switch</span>)), <span class="dt">size =</span> <span class="dv">2</span>, <span class="dt">alpha =</span> <span class="fl">0.85</span>) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb8-8" title="8"><span class="st">  </span><span class="kw">scale_fill_gradient</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb8-9" title="9"><span class="st">  </span><span class="kw">scale_color_manual</span>(<span class="st">&quot;switch&quot;</span>, <span class="dt">values =</span> <span class="kw">c</span>(<span class="st">&quot;white&quot;</span>, <span class="st">&quot;black&quot;</span>), <span class="dt">labels =</span> <span class="kw">c</span>(<span class="st">&quot;No&quot;</span>, <span class="st">&quot;Yes&quot;</span>))</a></code></pre></div>
<p>We can see that the black points (<code>switch=1</code>) are predominantly clustered in the upper-left region of the plot where the predicted probability of switching is highest.</p>
<p>Another way we can visualize the data and model is to follow Gelman and Hill and create separate plots for varying the arsenic level and distance. Here we’ll plot curves representing the predicted probability of switching for the minimum, maximum and quartile values of both variables.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" title="1"><span class="co"># Quantiles</span></a>
<a class="sourceLine" id="cb9-2" title="2">q_ars &lt;-<span class="st"> </span><span class="kw">quantile</span>(wells<span class="op">$</span>dist100, <span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="fl">0.25</span>))</a>
<a class="sourceLine" id="cb9-3" title="3">q_dist &lt;-<span class="st"> </span><span class="kw">quantile</span>(wells<span class="op">$</span>arsenic, <span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="fl">0.25</span>))  </a>
<a class="sourceLine" id="cb9-4" title="4">base &lt;-<span class="st"> </span><span class="kw">ggplot</span>(wells) <span class="op">+</span><span class="st"> </span><span class="kw">xlim</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="ot">NA</span>)) <span class="op">+</span></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="st">  </span><span class="kw">scale_y_continuous</span>(<span class="dt">breaks =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">0.5</span>, <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb9-6" title="6">vary_arsenic &lt;-<span class="st"> </span>base <span class="op">+</span><span class="st"> </span><span class="kw">jitt</span>(<span class="dt">x=</span><span class="st">&quot;arsenic&quot;</span>, <span class="dt">y=</span><span class="st">&quot;switch&quot;</span>, <span class="dt">color=</span><span class="st">&quot;switch&quot;</span>)</a>
<a class="sourceLine" id="cb9-7" title="7">vary_dist &lt;-<span class="st"> </span>base <span class="op">+</span><span class="st"> </span><span class="kw">jitt</span>(<span class="dt">x=</span><span class="st">&quot;dist100&quot;</span>, <span class="dt">y=</span><span class="st">&quot;switch&quot;</span>, <span class="dt">color=</span><span class="st">&quot;switch&quot;</span>)</a>
<a class="sourceLine" id="cb9-8" title="8"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>) {</a>
<a class="sourceLine" id="cb9-9" title="9">  vary_dist &lt;-<span class="st"> </span></a>
<a class="sourceLine" id="cb9-10" title="10"><span class="st">    </span>vary_dist <span class="op">+</span><span class="st"> </span><span class="kw">stat_function</span>(<span class="dt">fun =</span> pr_switch2, <span class="dt">color =</span> <span class="st">&quot;gray35&quot;</span>, </a>
<a class="sourceLine" id="cb9-11" title="11">                              <span class="dt">args =</span> <span class="kw">list</span>(<span class="dt">ests =</span> <span class="kw">coef</span>(fit2), <span class="dt">y =</span> q_dist[i]))</a>
<a class="sourceLine" id="cb9-12" title="12">  vary_arsenic &lt;-</a>
<a class="sourceLine" id="cb9-13" title="13"><span class="st">    </span>vary_arsenic <span class="op">+</span><span class="st"> </span><span class="kw">stat_function</span>(<span class="dt">fun =</span> pr_switch2, <span class="dt">color =</span> <span class="st">&quot;gray35&quot;</span>, </a>
<a class="sourceLine" id="cb9-14" title="14">                                 <span class="dt">args =</span> <span class="kw">list</span>(<span class="dt">ests =</span> <span class="kw">coef</span>(fit2), <span class="dt">x =</span> q_ars[i]))</a>
<a class="sourceLine" id="cb9-15" title="15">}</a>
<a class="sourceLine" id="cb9-16" title="16"><span class="kw">bayesplot_grid</span>(vary_dist, vary_arsenic, </a>
<a class="sourceLine" id="cb9-17" title="17">               <span class="dt">grid_args =</span> <span class="kw">list</span>(<span class="dt">ncol =</span> <span class="dv">2</span>))</a></code></pre></div>
<p>We can compare our two models (with and without <code>arsenic</code>) using an approximation to Leave-One-Out (LOO) cross-validation, which is a method for estimating out of sample predictive performance and is implemented by the <code>loo</code> function in the <strong>loo</strong> package:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" title="1">(loo1 &lt;-<span class="st"> </span><span class="kw">loo</span>(fit1))</a>
<a class="sourceLine" id="cb10-2" title="2">(loo2 &lt;-<span class="st"> </span><span class="kw">loo</span>(fit2))</a>
<a class="sourceLine" id="cb10-3" title="3"><span class="kw">loo_compare</span>(loo1, loo2)</a></code></pre></div>
<p>These results favor <code>fit2</code> over <code>fit1</code>, as the estimated difference in <code>elpd</code> (the expected log pointwise predictive density for a new dataset) is so much larger than its standard error. LOO penalizes models for adding additional predictors (this helps counter overfitting), but in this case <code>fit2</code> represents enough of an improvement over <code>fit1</code> that the penalty for including <code>arsenic</code> is negligible (as it should be if <code>arsenic</code> is an important predictor).</p>
<p>The <a href="lm.html">vignette</a> for the <code>stan_lm</code> function also has an example of using the <code>loo</code> function where the results are quite a bit different from what we see here and some important additional considerations are discussed.</p>
</div>
<div id="conditional-logit-models" class="section level1">
<h1>Conditional Logit Models</h1>
<p>The previous example relies on the fact that observations are plausibly conditionally independent. In contrast, so-called “case-control studies” require that there are a fixed number of successes and failures within each stratum, and the question is <em>which</em> members of each stratum succeed and fail? The <code>stan_clogit</code> function estimates such a model and is very similar to the <code>clogit</code> function in the <strong>survival</strong> package. The main syntactical difference is that the <code>clogit</code> function requires that the user call the <code>strata</code> function in the model formula, whereas the <code>stan_clogit</code> function has a required <code>strata</code> argument. In addition, in the <code>stan_clogit</code> case the data must be sorted by the variable passed to <code>strata</code>. The advantage to these changes is that <code>stan_clogit</code> can optionally utilize the multilevel syntax from the <strong>lme4</strong> package to specify group-specific terms, rather than the more limited multilevel structure supported by the <code>frailty</code> function in the <strong>survival</strong> package. The <a href="glmer.html">vignette</a> for the <code>stan_glmer</code> function discusses the lme4-style syntax in more detail. For example,</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" title="1">post &lt;-<span class="st"> </span><span class="kw">stan_clogit</span>(case <span class="op">~</span><span class="st"> </span>spontaneous <span class="op">+</span><span class="st"> </span>induced <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">|</span><span class="st"> </span>parity), </a>
<a class="sourceLine" id="cb11-2" title="2">                    <span class="dt">data =</span> infert[<span class="kw">order</span>(infert<span class="op">$</span>stratum), ], <span class="co"># order necessary</span></a>
<a class="sourceLine" id="cb11-3" title="3">                    <span class="dt">strata =</span> stratum, <span class="dt">QR =</span> <span class="ot">TRUE</span>, </a>
<a class="sourceLine" id="cb11-4" title="4">                    <span class="dt">cores =</span> <span class="dv">2</span>, <span class="dt">seed =</span> <span class="dv">12345</span>)</a></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" title="1">post</a></code></pre></div>
<p>The posterior predictions are also constrained such that there is exactly one success (in this case) for each of the strata and thus the posterior distribution of the probabilities are also so constrained:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb13-1" title="1">PPD &lt;-<span class="st"> </span><span class="kw">posterior_predict</span>(post)</a>
<a class="sourceLine" id="cb13-2" title="2"><span class="kw">stopifnot</span>(<span class="kw">rowSums</span>(PPD) <span class="op">==</span><span class="st"> </span><span class="kw">max</span>(infert<span class="op">$</span>stratum))</a>
<a class="sourceLine" id="cb13-3" title="3">PLP &lt;-<span class="st"> </span><span class="kw">posterior_linpred</span>(post, <span class="dt">transform =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb13-4" title="4"><span class="kw">stopifnot</span>(<span class="kw">round</span>(<span class="kw">rowSums</span>(PLP)) <span class="op">==</span><span class="st"> </span><span class="kw">max</span>(infert<span class="op">$</span>stratum))</a></code></pre></div>
</div>
<div id="binomial-models" class="section level1">
<h1>Binomial Models</h1>
<p>Although the example in this vignette focused on a binary response variable, we can use nearly identical code if we have the sum of multiple binary variables. For example, image a hypothetical dataset similar to the well-switching data but spanning multiple villages. Each observation (each row) of this <code>data.frame</code> corresponds to an entire village: <code>switch[i]</code> is the number of ‘yes’ responses to the well-switching question for village <code>i</code>, <code>dist100[i]</code> is the average distance to the closest well with clean water for village <code>i</code>, etc. We also now have a variable <code>n</code> where <code>n[i]</code> is the number of respondents from village <code>i</code>.</p>
<p>For this data we can estimate a similar model to the one we used in the binary case by changing the formula to</p>
<p><code>cbind(switch, n - switch) ~ dist100 + arsenic</code></p>
<p>The left-hand side is now a 2-column matrix where the first column is the number of ‘yes’ responses and the second column is the number of ‘no’ responses (or more generally, the number of successes and number of failures). The same model can also be specified using the proportion of ‘yes’ responses and the total number of responses in each village. This corresponds to the formula</p>
<p><code>prop_switch ~ dist100 + arsenic</code></p>
<p>where <code>prop_switch = switch / n</code> is the proportion of ‘yes’ responses. The total number of responses is provided using the <code>weights</code> argument. In this case we would add <code>weights = n</code> to the call to <code>stan_glm</code>.</p>
<p>An example of a similar model can also be found in <strong>Step 1</strong> of the <a href="rstanarm.html">“How to Use the <strong>rstanarm</strong> Package”</a> vignette.</p>
</div>
<div id="going-further" class="section level1">
<h1>Going Further</h1>
<p>In the hypothetical scenario above, if we also have access to the observations for each individual in all of the villages (not just the aggregate data), then a natural extension would be to consider a multilevel model that takes advantage of the inherent multilevel structure of the data (individuals nested within villages). The <a href="glmer.html">vignette</a> for the <code>stan_glmer</code> function discusses these models.</p>
</div>
<div id="references" class="section level1">
<h1>References</h1>
<p>Gelman, A. and Hill, J. (2007). <em>Data Analysis Using Regression and Multilevel/Hierarchical Models.</em> Cambridge University Press, Cambridge, UK.</p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
