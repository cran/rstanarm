<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Jonah Gabry and Ben Goodrich" />

<meta name="date" content="2019-10-01" />

<title>Estimating Regularized Linear Models with rstanarm</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#header {
text-align: center;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; }  code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>

</head>

<body>




<h1 class="title toc-ignore">Estimating Regularized Linear Models with rstanarm</h1>
<h4 class="author"><em>Jonah Gabry and Ben Goodrich</em></h4>
<h4 class="date"><em>2019-10-01</em></h4>


<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#likelihood">Likelihood</a></li>
<li><a href="#qr-decomposition">QR Decomposition</a></li>
<li><a href="#priors">Priors</a></li>
<li><a href="#posterior">Posterior</a></li>
<li><a href="#example">Example</a></li>
<li><a href="#alternative-approach">Alternative Approach</a></li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>

<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{stan_lm: Regularized Linear Models}
-->
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>This vignette explains how to estimate linear models using the <code>stan_lm</code> function in the <strong>rstanarm</strong> package.</p>
<p>Steps 3 and 4 are covered in more depth by the vignette entitled <a href="rstanarm.html">“How to Use the <strong>rstanarm</strong> Package”</a>. This vignette focuses on Step 1 when the likelihood is the product of independent normal distributions.</p>
<p>The goal of the <strong>rstanarm</strong> package is to make Bayesian estimation of common regression models routine. That goal can be partially accomplished by providing interfaces that are similar to the popular formula-based interfaces to frequentist estimators of those regression models. But fully accomplishing that goal sometimes entails utilizing priors that applied researchers are unaware that they prefer. These priors are intended to work well for any data that a user might pass to the interface that was generated according to the assumptions of the likelihood function.</p>
<p>It is important to distinguish between priors that are easy for applied researchers to <em>specify</em> and priors that are easy for applied researchers to <em>conceptualize</em>. The prior described below emphasizes the former but we outline its derivation so that applied researchers may feel more comfortable utilizing it.</p>
</div>
<div id="likelihood" class="section level1">
<h1>Likelihood</h1>
<p>The likelihood for one observation under a linear model can be written as a conditionally normal PDF <span class="math display">\[\frac{1}{\sigma_{\epsilon} \sqrt{2 \pi}} 
  e^{-\frac{1}{2} \left(\frac{y - \mu}{\sigma_{\epsilon}}\right)^2},\]</span> where <span class="math inline">\(\mu = \alpha + \mathbf{x}^\top \boldsymbol{\beta}\)</span> is a linear predictor and <span class="math inline">\(\sigma_{\epsilon}\)</span> is the standard deviation of the error in predicting the outcome, <span class="math inline">\(y\)</span>. The likelihood of the entire sample is the product of <span class="math inline">\(N\)</span> individual likelihood contributions.</p>
<p>It is well-known that the likelihood of the sample is maximized when the sum-of-squared residuals is minimized, which occurs when <span class="math display">\[ \widehat{\boldsymbol{\beta}} = \left(\mathbf{X}^\top \mathbf{X}\right)^{-1}
                                   \mathbf{X}^\top \mathbf{y}, \]</span> <span class="math display">\[ \widehat{\alpha} = \overline{y} - \overline{\mathbf{x}}^\top 
                                     \widehat{\boldsymbol{\beta}}, \]</span> <span class="math display">\[ \widehat{\sigma}_{\epsilon}^2 = 
  \frac{\left(\mathbf{y} - \widehat{\alpha} - \mathbf{X} \widehat{
                                              \boldsymbol{\beta}}\right)^\top
        \left(\mathbf{y} - \widehat{\alpha} - \mathbf{X} \widehat{
                                              \boldsymbol{\beta}}\right)}{N},\]</span> where <span class="math inline">\(\overline{\mathbf{x}}\)</span> is a vector that contains the sample means of the <span class="math inline">\(K\)</span> predictors, <span class="math inline">\(\mathbf{X}\)</span> is a <span class="math inline">\(N \times K\)</span> matrix of <em>centered</em> predictors, <span class="math inline">\(\mathbf{y}\)</span> is a <span class="math inline">\(N\)</span>-vector of outcomes and <span class="math inline">\(\overline{y}\)</span> is the sample mean of the outcome.</p>
</div>
<div id="qr-decomposition" class="section level1">
<h1>QR Decomposition</h1>
<p>The <code>lm</code> function in R actually performs a QR decomposition of the design matrix, <span class="math inline">\(\mathbf{X} = \mathbf{Q}\mathbf{R}\)</span>, where <span class="math inline">\(\mathbf{Q}^\top \mathbf{Q} = \mathbf{I}\)</span> and <span class="math inline">\(\mathbf{R}\)</span> is upper triangular. Thus, the OLS solution for the coefficients can be written as <span class="math inline">\(\left(\mathbf{X}^\top \mathbf{X}\right)^{-1} \mathbf{X}^\top \mathbf{y} =  \mathbf{R}^{-1} \mathbf{Q}^\top \mathbf{y}\)</span>. The <code>lm</code> function utilizes the QR decomposition for numeric stability reasons, but the QR decomposition is also useful for thinking about priors in a Bayesian version of the linear model. In addition, writing the likelihood in terms of <span class="math inline">\(\mathbf{Q}\)</span> allows it to be evaluated in a very efficient manner in Stan.</p>
</div>
<div id="priors" class="section level1">
<h1>Priors</h1>
<p>The key innovation in the <code>stan_lm</code> function in the <strong>rstanarm</strong> package is the prior for the parameters in the QR-reparameterized model. To understand this prior, think about the equations that characterize the maximum likelihood solutions before observing the data on <span class="math inline">\(\mathbf{X}\)</span> and especially <span class="math inline">\(\mathbf{y}\)</span>.</p>
<p>What would the prior distribution of <span class="math inline">\(\boldsymbol{\theta} = \mathbf{Q}^\top \mathbf{y}\)</span> be? We can write its <span class="math inline">\(k\)</span>-th element as <span class="math inline">\(\theta_k = \rho_k \sigma_Y \sqrt{N - 1}\)</span> where <span class="math inline">\(\rho_k\)</span> is the correlation between the <span class="math inline">\(k\)</span>th column of <span class="math inline">\(\mathbf{Q}\)</span> and the outcome, <span class="math inline">\(\sigma_Y\)</span> is the standard deviation of the outcome, and <span class="math inline">\(\frac{1}{\sqrt{N-1}}\)</span> is the standard deviation of the <span class="math inline">\(k\)</span> column of <span class="math inline">\(\mathbf{Q}\)</span>. Then let <span class="math inline">\(\boldsymbol{\rho} = \sqrt{R^2}\mathbf{u}\)</span> where <span class="math inline">\(\mathbf{u}\)</span> is a unit vector that is uniformly distributed on the surface of a hypersphere. Consequently, <span class="math inline">\(R^2 = \boldsymbol{\rho}^\top \boldsymbol{\rho}\)</span> is the familiar coefficient of determination for the linear model.</p>
<p>An uninformative prior on <span class="math inline">\(R^2\)</span> would be standard uniform, which is a special case of a Beta distribution with both shape parameters equal to <span class="math inline">\(1\)</span>. A non-uniform prior on <span class="math inline">\(R^2\)</span> is somewhat analogous to ridge regression, which is popular in data mining and produces better out-of-sample predictions than least squares because it penalizes <span class="math inline">\(\boldsymbol{\beta}^\top \boldsymbol{\beta}\)</span>, usually after standardizing the predictors. An informative prior on <span class="math inline">\(R^2\)</span> effectively penalizes <span class="math inline">\(\boldsymbol{\rho}\top \boldsymbol{\rho}\)</span>, which encourages <span class="math inline">\(\boldsymbol{\beta} = \mathbf{R}^{-1} \boldsymbol{\theta}\)</span> to be closer to the origin.</p>
<p>Lewandowski, Kurowicka, and Joe (2009) derives a distribution for a correlation matrix that depends on a single shape parameter <span class="math inline">\(\eta &gt; 0\)</span>, which implies the variance of one variable given the remaining <span class="math inline">\(K\)</span> variables is <span class="math inline">\(\mathrm{Beta}\left(\eta,\frac{K}{2}\right)\)</span>. Thus, the <span class="math inline">\(R^2\)</span> is distributed <span class="math inline">\(\mathrm{Beta}\left(\frac{K}{2},\eta\right)\)</span> and any prior information about the location of <span class="math inline">\(R^2\)</span> can be used to choose a value of the hyperparameter <span class="math inline">\(\eta\)</span>. The <code>R2(location, what)</code> function in the <strong>rstanarm</strong> package supports four ways of choosing <span class="math inline">\(\eta\)</span>:</p>
<ol style="list-style-type: decimal">
<li><code>what = &quot;mode&quot;</code> and <code>location</code> is some prior mode on the <span class="math inline">\(\left(0,1\right)\)</span> interval. This is the default but since the mode of a <span class="math inline">\(\mathrm{Beta}\left(\frac{K}{2},\eta\right)\)</span> distribution is <span class="math inline">\(\frac{\frac{K}{2} - 1}{\frac{K}{2} + \eta - 2}\)</span> the mode only exists if <span class="math inline">\(K &gt; 2\)</span>. If <span class="math inline">\(K \leq 2\)</span>, then the user must specify something else for <code>what</code>.</li>
<li><code>what = &quot;mean&quot;</code> and <code>location</code> is some prior mean on the <span class="math inline">\(\left(0,1\right)\)</span> interval, where the mean of a <span class="math inline">\(\mathrm{Beta}\left(\frac{K}{2},\eta\right)\)</span> distribution is <span class="math inline">\(\frac{\frac{K}{2}}{\frac{K}{2} + \eta}\)</span>.</li>
<li><code>what = &quot;median&quot;</code> and <code>location</code> is some prior median on the <span class="math inline">\(\left(0,1\right)\)</span> interval. The median of a <span class="math inline">\(\mathrm{Beta}\left(\frac{K}{2},\eta\right)\)</span> distribution is not available in closed form but if <span class="math inline">\(K &gt; 2\)</span> it is approximately equal to <span class="math inline">\(\frac{\frac{K}{2} - \frac{1}{3}}{\frac{K}{2} + \eta - \frac{2}{3}}\)</span>. Regardless of whether <span class="math inline">\(K &gt; 2\)</span>, the <code>R2</code> function can numerically solve for the value of <span class="math inline">\(\eta\)</span> that is consistent with a given prior median utilizing the quantile function.</li>
<li><code>what = &quot;log&quot;</code> and <code>location</code> is some (negative) prior value for <span class="math inline">\(\mathbb{E} \ln R^2 = \psi\left(\frac{K}{2}\right)-  \psi\left(\frac{K}{2}+\eta\right)\)</span>, where <span class="math inline">\(\psi\left(\cdot\right)\)</span> is the <code>digamma</code> function. Again, given a prior value for the left-hand side it is easy to numerically solve for the corresponding value of <span class="math inline">\(\eta\)</span>.</li>
</ol>
<p>There is no default value for the <code>location</code> argument of the <code>R2</code> function. This is an <em>informative</em> prior on <span class="math inline">\(R^2\)</span>, which must be chosen by the user in light of the research project. However, specifying <code>location = 0.5</code> is often safe, in which case <span class="math inline">\(\eta = \frac{K}{2}\)</span> regardless of whether <code>what</code> is <code>&quot;mode&quot;</code>, <code>&quot;mean&quot;</code>, or <code>&quot;median&quot;</code>. In addition, it is possible to specify <code>NULL</code>, in which case a standard uniform on <span class="math inline">\(R^2\)</span> is utilized.</p>
<p>We set <span class="math inline">\(\sigma_y = \omega s_y\)</span> where <span class="math inline">\(s_y\)</span> is the sample standard deviation of the outcome and <span class="math inline">\(\omega &gt; 0\)</span> is an unknown scale parameter to be estimated. The only prior for <span class="math inline">\(\omega\)</span> that does not contravene Bayes’ theorem in this situation is Jeffreys prior, <span class="math inline">\(f\left(\omega\right) \propto \frac{1}{\omega}\)</span>, which is proportional to a Jeffreys prior on the unknown <span class="math inline">\(\sigma_y\)</span>, <span class="math inline">\(f\left(\sigma_y\right) \propto \frac{1}{\sigma_y} = \frac{1}{\omega \widehat{\sigma}_y} \propto \frac{1}{\omega}\)</span>. This parameterization and prior makes it easy for Stan to work with any continuous outcome variable, no matter what its units of measurement are.</p>
<p>It would seem that we need a prior for <span class="math inline">\(\sigma_{\epsilon}\)</span>, but our prior beliefs about <span class="math inline">\(\sigma_{\epsilon} = \omega s_y \sqrt{1 - R^2}\)</span> are already implied by our prior beliefs about <span class="math inline">\(\omega\)</span> and <span class="math inline">\(R^2\)</span>. That only leaves a prior for <span class="math inline">\(\alpha = \overline{y} - \overline{\mathbf{x}}^\top \mathbf{R}^{-1} \boldsymbol{\theta}\)</span>. The default choice is an improper uniform prior, but a normal prior can also be specified such as one with mean zero and standard deviation <span class="math inline">\(\frac{\sigma_y}{\sqrt{N}}\)</span>.</p>
</div>
<div id="posterior" class="section level1">
<h1>Posterior</h1>
<p>The previous sections imply a posterior distribution for <span class="math inline">\(\omega\)</span>, <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\mathbf{u}\)</span>, and <span class="math inline">\(R^2\)</span>. The parameters of interest can then be recovered as generated quantities:</p>
<ul>
<li><span class="math inline">\(\sigma_y = \omega s_y\)</span></li>
<li><span class="math inline">\(\sigma_{\epsilon} = \sigma_y \sqrt{1 - R^2}\)</span></li>
<li><span class="math inline">\(\boldsymbol{\beta} = \mathbf{R}^{-1} \mathbf{u} \sigma_y \sqrt{R^2 \left(N-1\right)}\)</span></li>
</ul>
<p>The implementation actually utilizes an improper uniform prior on <span class="math inline">\(\ln \omega\)</span>. Consequently, if <span class="math inline">\(\ln \omega = 0\)</span>, then the marginal standard deviation of the outcome <em>implied by the model</em> is the same as the sample standard deviation of the outcome. If <span class="math inline">\(\ln \omega &gt; 0\)</span>, then the marginal standard deviation of the outcome implied by the model exceeds the sample standard deviation, so the model overfits the data. If <span class="math inline">\(\ln \omega &lt; 0\)</span>, then the marginal standard deviation of the outcome implied by the model is less than the sample standard deviation, so the model <em>underfits</em> the data or that the data-generating process is nonlinear. Given the regularizing nature of the prior on <span class="math inline">\(R^2\)</span>, a minor underfit would be considered ideal if the goal is to obtain good out-of-sample predictions. If the model badly underfits or overfits the data, then you may want to reconsider the model.</p>
</div>
<div id="example" class="section level1">
<h1>Example</h1>
<p>We will utilize an example from the <strong>HSAUR3</strong> package by Brian S. Everitt and Torsten Hothorn, which is used in their 2014 book <em>A Handbook of Statistical Analyses Using R (3rd Edition)</em> (Chapman &amp; Hall / CRC). This book is frequentist in nature and we will show how to obtain the corresponding Bayesian results.</p>
<p>The model in section 5.3.1 analyzes an experiment where clouds were seeded with different amounts of silver iodide to see if there was increased rainfall. This effect could vary according to covariates, which (except for <code>time</code>) are interacted with the treatment variable. Most people would probably be skeptical that cloud hacking could explain very much of the variation in rainfall and thus the prior mode of the <span class="math inline">\(R^2\)</span> would probably be fairly small.</p>
<p>The frequentist estimator of this model can be replicated by executing</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">data</span>(<span class="st">&quot;clouds&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;HSAUR3&quot;</span>)</a>
<a class="sourceLine" id="cb1-2" title="2">ols &lt;-<span class="st"> </span><span class="kw">lm</span>(rainfall <span class="op">~</span><span class="st"> </span>seeding <span class="op">*</span><span class="st"> </span>(sne <span class="op">+</span><span class="st"> </span>cloudcover <span class="op">+</span><span class="st"> </span>prewetness <span class="op">+</span><span class="st"> </span>echomotion) <span class="op">+</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="st">            </span>time, <span class="dt">data =</span> clouds)</a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">round</span>(<span class="kw">coef</span>(ols), <span class="dv">3</span>)</a></code></pre></div>
<p>Note that we have <em>not</em> looked at the estimated <span class="math inline">\(R^2\)</span> or <span class="math inline">\(\sigma\)</span> for the ordinary least squares model. We can estimate a Bayesian version of this model by prepending <code>stan_</code> to the <code>lm</code> call, specifying a prior mode for <span class="math inline">\(R^2\)</span>, and optionally specifying how many cores the computer may utilize:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">library</span>(rstanarm)</a>
<a class="sourceLine" id="cb2-2" title="2">post &lt;-</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="st">  </span><span class="kw">stan_lm</span>(</a>
<a class="sourceLine" id="cb2-4" title="4">    rainfall <span class="op">~</span><span class="st"> </span>seeding <span class="op">*</span><span class="st"> </span>(sne <span class="op">+</span><span class="st"> </span>cloudcover <span class="op">+</span><span class="st"> </span>prewetness <span class="op">+</span><span class="st"> </span>echomotion) <span class="op">+</span><span class="st"> </span>time,</a>
<a class="sourceLine" id="cb2-5" title="5">    <span class="dt">data =</span> clouds,</a>
<a class="sourceLine" id="cb2-6" title="6">    <span class="dt">prior =</span> <span class="kw">R2</span>(<span class="dt">location =</span> <span class="fl">0.2</span>),</a>
<a class="sourceLine" id="cb2-7" title="7">    <span class="dt">seed =</span> <span class="dv">12345</span></a>
<a class="sourceLine" id="cb2-8" title="8">  )</a>
<a class="sourceLine" id="cb2-9" title="9">post</a></code></pre></div>
<p>In this case, the “Bayesian point estimates”, which are represented by the posterior medians, appear quite different from the ordinary least squares estimates. However, the <code>log-fit_ratio</code> (i.e. <span class="math inline">\(\ln \omega\)</span>) is quite small, indicating that the model only slightly overfits the data when the prior derived above is utilized. Thus, it would be safe to conclude that the ordinary least squares estimator considerably overfits the data since there are only <span class="math inline">\(24\)</span> observations to estimate <span class="math inline">\(12\)</span> parameters with and no prior information on the parameters.</p>
<p>Also, it is not obvious what the estimated average treatment effect is since the treatment variable, <code>seeding</code>, is interacted with four other correlated predictors. However, it is easy to estimate or visualize the average treatment effect (ATE) using <strong>rstanarm</strong>’s <code>posterior_predict</code> function.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" title="1">clouds_cf &lt;-<span class="st"> </span>clouds</a>
<a class="sourceLine" id="cb3-2" title="2">clouds_cf<span class="op">$</span>seeding[] &lt;-<span class="st"> &quot;yes&quot;</span></a>
<a class="sourceLine" id="cb3-3" title="3">y1_rep &lt;-<span class="st"> </span><span class="kw">posterior_predict</span>(post, <span class="dt">newdata =</span> clouds_cf)</a>
<a class="sourceLine" id="cb3-4" title="4">clouds_cf<span class="op">$</span>seeding[] &lt;-<span class="st"> &quot;no&quot;</span></a>
<a class="sourceLine" id="cb3-5" title="5">y0_rep &lt;-<span class="st"> </span><span class="kw">posterior_predict</span>(post, <span class="dt">newdata =</span> clouds_cf)</a>
<a class="sourceLine" id="cb3-6" title="6"><span class="kw">qplot</span>(<span class="dt">x =</span> <span class="kw">c</span>(y1_rep <span class="op">-</span><span class="st"> </span>y0_rep), <span class="dt">geom =</span> <span class="st">&quot;histogram&quot;</span>, <span class="dt">xlab =</span> <span class="st">&quot;Estimated ATE&quot;</span>)</a></code></pre></div>
<p>As can be seen, the treatment effect is not estimated precisely and is as almost as likely to be negative as it is to be positive.</p>
</div>
<div id="alternative-approach" class="section level1">
<h1>Alternative Approach</h1>
<p>The prior derived above works well in many situations and is quite simple to <em>use</em> since it only requires the user to specify the prior location of the <span class="math inline">\(R^2\)</span>. Nevertheless, the implications of the prior are somewhat difficult to <em>conceptualize</em>. Thus, it is perhaps worthwhile to compare to another estimator of a linear model that simply puts independent Cauchy priors on the regression coefficients. This simpler approach can be executed by calling the <code>stan_glm</code> function with <code>family = gaussian()</code> and specifying the priors:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" title="1">simple &lt;-</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="st">  </span><span class="kw">stan_glm</span>(</a>
<a class="sourceLine" id="cb4-3" title="3">    rainfall <span class="op">~</span><span class="st"> </span>seeding <span class="op">*</span><span class="st"> </span>(sne <span class="op">+</span><span class="st"> </span>cloudcover <span class="op">+</span><span class="st"> </span>prewetness <span class="op">+</span><span class="st"> </span>echomotion) <span class="op">+</span><span class="st"> </span>time,</a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="dt">data =</span> clouds,</a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="dt">family =</span> <span class="kw">gaussian</span>(),</a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="dt">prior =</span> <span class="kw">cauchy</span>(),</a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="dt">prior_intercept =</span> <span class="kw">cauchy</span>(),</a>
<a class="sourceLine" id="cb4-8" title="8">    <span class="dt">seed =</span> <span class="dv">12345</span></a>
<a class="sourceLine" id="cb4-9" title="9">  )</a></code></pre></div>
<p>We can compare the two approaches using an approximation to Leave-One-Out (LOO) cross-validation, which is implemented by the <code>loo</code> function in the <strong>loo</strong> package.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" title="1">(loo_post &lt;-<span class="st"> </span><span class="kw">loo</span>(post))</a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">loo_compare</span>(loo_post, <span class="kw">loo</span>(simple))</a></code></pre></div>
<p>The results indicate that the first approach is expected to produce better out-of-sample predictions but the Warning messages are at least as important. Many of the estimated shape parameters for the Generalized Pareto distribution are above <span class="math inline">\(0.5\)</span> in the model with Cauchy priors, which indicates that these estimates are only going to converge slowly to the true out-of-sample deviance measures. Thus, with only <span class="math inline">\(24\)</span> observations, they should not be considered reliable. The more complicated prior derived above is stronger — as evidenced by the fact that the effective number of parameters is about half of that in the simpler approach and <span class="math inline">\(12\)</span> for the maximum likelihood estimator — and only has a few of the <span class="math inline">\(24\)</span> Pareto shape estimates in the “danger zone”. We might want to reexamine these observations</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">plot</span>(loo_post, <span class="dt">label_points =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<p>because the posterior is sensitive to them but, overall, the results seem tolerable.</p>
<p>In general, we would expect the joint prior derived here to work better when there are many predictors relative to the number of observations. Placing independent, heavy-tailed priors on the coefficients neither reflects the beliefs of the researcher nor conveys enough information to stabilize all the computations.</p>
</div>
<div id="conclusion" class="section level1">
<h1>Conclusion</h1>
<p>This vignette has discussed the prior distribution utilized in the <code>stan_lm</code> function, which has the same likelihood and a similar syntax as the <code>lm</code> function in R but adds the ability to expression prior beliefs about the location of the <span class="math inline">\(R^2\)</span>, which is the familiar proportion of variance in the outcome variable that is attributable to the predictors under a linear model. Since the <span class="math inline">\(R^2\)</span> is a well-understood bounded scalar, it is easy to specify prior information about it, whereas other Bayesian approaches require the researcher to specify a joint prior distribution for the regression coefficients (and the intercept and error variance).</p>
<p>However, most researchers have little inclination to specify all these prior distributions thoughtfully and take a short-cut by specifying one prior distribution that is taken to apply to all the regression coefficients as if they were independent of each other (and the intercept and error variance). This short-cut is available in the <code>stan_glm</code> function and is described in more detail in other <strong>rstanarm</strong> vignettes for Generalized Linear Models (GLMs), which can be found by navigating up one level.</p>
<p>We are optimistic that this prior on the <span class="math inline">\(R^2\)</span> will greatly help in accomplishing our goal for <strong>rstanarm</strong> of making Bayesian estimation of regression models routine. The same approach is used to specify a prior in ANOVA models (see <code>stan_aov</code>) and proportional-odds models for ordinal outcomes (see <code>stan_polr</code>).</p>
<p>Finally, the <code>stan_biglm</code> function can be used when the design matrix is too large for the <code>qr</code> function to process. The <code>stan_biglm</code> function inputs the output of the <code>biglm</code> function in the <strong>biglm</strong> package, which utilizes an incremental QR decomposition that does not require the entire dataset to be loaded into memory simultaneously. However, the <code>biglm</code> function needs to be called in a particular way in order to work with <code>stan_biglm</code>. In particular, The means of the columns of the design matrix, the sample mean of the outcome, and the sample standard deviation of the outcome all need to be passed to the <code>stan_biglm</code> function, as well as a flag indicating whether the model really does include an intercept. Also, the number of columns of the design matrix currently cannot exceed the number of rows. Although <code>stan_biglm</code> should run fairly quickly and without much memory, the resulting object is a fairly plain <code>stanfit</code> object rather than an enhanced <code>stanreg</code> object like that produced by <code>stan_lm</code>. Many of the enhanced capabilities of a <code>stanreg</code> object depend on being able to access the full design matrix, so doing posterior predictions, posterior checks, etc. with the output of <code>stan_biglm</code> would require some custom R code.</p>
</div>
<div id="references" class="section level1">
<h1>References</h1>
<p>Lewandowski, D., Kurowicka D., and Joe, H. (2009). Generating random correlation matrices based on vines and extended onion method. <em>Journal of Multivariate Analysis</em>. <strong>100</strong>(9), 1989–2001.</p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
